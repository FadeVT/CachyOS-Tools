#!/bin/bash
# cachy-update main-update â€” core update logic for CachyOS
# shellcheck disable=SC2015
set -e

# â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
init_logging() {
    if [ ! -d /var/log/cachy-update/ ]; then
        # shellcheck disable=SC2174
        mkdir -p -m 755 /var/log/cachy-update/
    fi
    echo -e "\n>-<->-< cachy-update at $(date +"%Y-%m-%d %R %Z(%:::z)")\n" >>/var/log/cachy-update/cachy-update.log
    exec &> >(stdbuf -i0 -o0 -e0 tee >(sed '/\x1b\[[0-9][EF]/d;/\r[^\n]$/d;s,\x1B\[[0-9;]*[a-zA-Z],,g' >>/var/log/cachy-update/cachy-update.log))
}

# â”€â”€â”€ Mirror refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
update_mirrorlist() {
    if [[ -v SKIP_MIRRORLIST ]]; then
        return
    fi

    # CachyOS mirrors â€” use cachyos-rate-mirrors if available
    if command -v cachyos-rate-mirrors >/dev/null; then
        echo -e "\n\033[1;33m-->\033[1;34m Refreshing CachyOS & Arch mirrorlists using cachyos-rate-mirrors, please be patient..ğŸµ\033[0m"
        cachyos-rate-mirrors >/dev/null 2>&1 || {
            echo -e "\033[1;33mcachyos-rate-mirrors failed. Continuing with existing CachyOS mirrors.\033[0m"
        }
        $INT
    fi

    # Arch mirrors â€” use rate-mirrors or reflector
    local MIRRORLIST_TEMP MINLINES=0
    MIRRORLIST_TEMP="$(mktemp)"

    if command -v rate-mirrors >/dev/null; then
        MINLINES=10
        echo -e "\n\033[1;33m-->\033[1;34m Refreshing Arch mirrorlist using rate-mirrors, please be patient..ğŸµ\033[0m"
        rate-mirrors --allow-root --save="$MIRRORLIST_TEMP" arch --max-delay=21600 >/dev/null || { rm -f "$MIRRORLIST_TEMP"; }
        $INT
    elif command -v reflector >/dev/null; then
        MINLINES=5
        echo -e "\n\033[1;33m-->\033[1;34m Refreshing Arch mirrorlist using reflector, please be patient..ğŸµ\033[0m"
        reflector --latest 10 --age 2 --fastest 10 --protocol https --sort rate --save "$MIRRORLIST_TEMP" || { rm -f "$MIRRORLIST_TEMP"; }
        $INT
    else
        rm -f "$MIRRORLIST_TEMP"
        return
    fi

    if [ ! -f "$MIRRORLIST_TEMP" ]; then
        echo -e "\033[1;33mFailed to update Arch mirrorlist. This can happen if the mirrorlist service is under load. Safely ignored.\n\033[0m"
        return
    fi

    if COUNT="$(grep -Ec "^Server *=" "$MIRRORLIST_TEMP")" && [ "$COUNT" -ge "$MINLINES" ]; then
        install -m644 "$MIRRORLIST_TEMP" /etc/pacman.d/mirrorlist
        DATABASE_UPDATED=true
    else
        echo -e "\033[1;31mNew mirrorlist does not contain enough mirrors. Skipping mirrorlist update.\033[0m"
    fi

    echo
    rm -f "$MIRRORLIST_TEMP"
}

# â”€â”€â”€ Keyring update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
update_keyrings() {
    echo -e "\n\033[1;33m-->\033[1;34m Updating keyrings..\033[0m"

    local keyring_pkgs=()
    pacman -Qi archlinux-keyring &>/dev/null && keyring_pkgs+=(archlinux-keyring)
    pacman -Qi cachyos-keyring &>/dev/null && keyring_pkgs+=(cachyos-keyring)
    pacman -Qi chaotic-keyring &>/dev/null && keyring_pkgs+=(chaotic-keyring)

    if [[ ${#keyring_pkgs[@]} -gt 0 ]]; then
        SNAP_PAC_SKIP=y $PACMAN -S --needed --noconfirm "${keyring_pkgs[@]}" || {
            echo -e "\033[1;33mKeyring update failed. Attempting keyring reinit...\033[0m"
            pacman-key --init
            pacman-key --populate archlinux 2>/dev/null || true
            pacman-key --populate cachyos 2>/dev/null || true
        }
    fi
}

# â”€â”€â”€ Pacman log parser for automatic retry logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
parse_pacman_log() {
    sed -i -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g" "$AUTOPACMAN_LOG"
    local reason
    reason="$(tac "$AUTOPACMAN_LOG" | grep -oP -m 1 '(?<=error: failed to commit transaction \().*(?=\))')" || return

    case "$reason" in
    # Corrupt package? Retry with direct CachyOS CDN
    "invalid or corrupted package"*)
        RETRY="Corrupt downloads detected. Retrying with CDN mirror..."
        CUSTOM_PACMAN_CONFIG="$(mktemp)"
        # Fallback: force CachyOS CDN77 mirror directly
        sed 's|Include = /etc/pacman.d/cachyos-mirrorlist|Server = https://cdn77.cachyos.org/repo/$arch/$repo|g' /etc/pacman.conf >"$CUSTOM_PACMAN_CONFIG"
        pacman_args+=("--config" "$CUSTOM_PACMAN_CONFIG")
        ;;
    # Download failure? Disable parallel downloads
    "download library error")
        RETRY="Download failures detected. Retrying with single connection..."
        CUSTOM_PACMAN_CONFIG="$(mktemp)"
        sed '/^ParallelDownloads.*/d' /etc/pacman.conf >"$CUSTOM_PACMAN_CONFIG"
        pacman_args+=("--config" "$CUSTOM_PACMAN_CONFIG")
        ;;
    # Python cache conflicts? Auto-overwrite
    "conflicting files")
        tac "$AUTOPACMAN_LOG" | gawk 'BEGIN { exitcode=1 }
                /error: failed to commit transaction \(conflicting files\)/ { exit exitcode }
                /\S+: (.*) exists in filesystem/ { if ($0 ~ /\S+: \/usr\/lib\/python[^\/]+\/site-packages\/[^/]+\/__pycache__\/.+\.pyc exists in filesystem/) { exitcode=0 } else { exit 1 } }
                ENDFILE {exit 1}' && pacman_args+=("--overwrite" "/usr/lib/python*/site-packages/*/__pycache__/*.pyc") && RETRY="Overwriting python cache file conflicts..." || true
        ;;
    esac
}

# â”€â”€â”€ Core update with auto-pacman (Expect wrapper) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
do_update() {
    if [ -x /usr/bin/expect ] && [ -x /usr/lib/cachy-update/auto-pacman ]; then
        local AUTOPACMAN_LOG EXIT=0 RETRY=false CUSTOM_PACMAN_CONFIG="" SUCCESS=false
        if [ ! -v AUTOPACMAN_CONFLICTSFILE ]; then
            local AUTOPACMAN_CONFLICTSFILE
            AUTOPACMAN_CONFLICTSFILE="$(mktemp -u)"
        fi
        AUTOPACMAN_LOG="$(mktemp)"

        LANG=C LANGUAGE=C LC_ALL=C \
            AUTOPACMAN_LOG="$AUTOPACMAN_LOG" \
            AUTOPACMAN_NO_SPACE_CHECK="${NO_SPACE_CHECK:-0}" \
            AUTOPACMAN_PACMAN_NOCONFIRM="${PACMAN_NOCONFIRM:-0}" \
            AUTOPACMAN_CONFLICTSFILE="$AUTOPACMAN_CONFLICTSFILE" \
            /usr/lib/cachy-update/auto-pacman "$PACMAN" "${pacman_args[@]}" || { EXIT=$?; }

        if [ -n "$CUSTOM_PACMAN_CONFIG" ]; then rm -f "$CUSTOM_PACMAN_CONFIG"; fi

        if [ "$EXIT" == "134" ] || [ "$EXIT" == "0" ]; then
            SUCCESS=true
        fi

        # Parse log for retryable errors
        if [ "$SUCCESS" != "true" ] && [ -z "$ALREADY_RETRIED" ]; then
            parse_pacman_log
        fi
        rm -f "$AUTOPACMAN_LOG"

        # Retry once if we identified a retryable failure
        if [ "$RETRY" != "false" ]; then
            echo -e "\n\033[1;33m-->\033[1;34m $RETRY \n\033[0m"
            ALREADY_RETRIED=true do_update
            return
        fi
        if [ -v AUTOPACMAN_CONFLICTSFILE ]; then
            rm -f "$AUTOPACMAN_CONFLICTSFILE"
            unset AUTOPACMAN_CONFLICTSFILE
        fi
        if [ "$SUCCESS" == "false" ]; then
            false
        fi
    else
        # Fallback: run pacman directly without Expect wrapper
        $PACMAN "${pacman_args[@]}"
    fi
}

# â”€â”€â”€ Pre-update hotfixes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pre_update_routines() {
    # Run any hotfix scripts in the hotfixes directory
    local hotfix_dir="/etc/cachy-update/hotfixes.d"
    if [ -d "$hotfix_dir" ]; then
        for fix in "$hotfix_dir"/*.sh; do
            if [ -f "$fix" ] && [ -x "$fix" ]; then
                echo -e "\033[1;33m-->\033[1;34m Applying hotfix: $(basename "$fix")\033[0m"
                # shellcheck source=/dev/null
                source "$fix" || true
            fi
        done
    fi

    # â”€â”€ Built-in package conflict removals â”€â”€
    # Add entries here when CachyOS packages conflict with deprecated ones.
    # Format: check if old package is installed, remove it before update
    #
    # Example:
    # if pacman -Qi some-deprecated-pkg &>/dev/null; then
    #     echo -e "\033[1;33m-->\033[1;34m Removing deprecated: some-deprecated-pkg\033[0m"
    #     SNAP_PAC_SKIP=y $PACMAN -Rdd --noconfirm some-deprecated-pkg 2>/dev/null || true
    # fi
    true
}

# â”€â”€â”€ Post-update routines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
post_update_routines() {
    # Update mlocate/plocate database
    if command -v updatedb >/dev/null; then
        updatedb 2>/dev/null &
    fi

    # Update fish completions
    if command -v fish >/dev/null && [ -n "$SUDO_UID" ]; then
        sudo -u "#$SUDO_UID" fish -c "fish_update_completions" 2>/dev/null || true
    fi

    # Update pkgfile database
    if command -v pkgfile >/dev/null; then
        pkgfile --update 2>/dev/null &
    fi

    # Wait for background jobs
    wait 2>/dev/null || true
}

# â”€â”€â”€ End routines: orphan check, pacnew, kernel reboot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
end_routines() {
    # Check for orphaned packages
    local orphans
    orphans="$(pacman -Qdtq 2>/dev/null)" || true
    if [ -n "$orphans" ]; then
        echo -e "\n\033[1;33m-->\033[1;34m Orphaned packages detected:\033[0m"
        echo "$orphans" | while read -r pkg; do
            echo -e "  \033[2mâ€¢\033[0m $pkg"
        done
        echo -e "\033[2m   Remove with: sudo pacman -Rns \$(pacman -Qdtq)\033[0m"
    fi

    # Check for .pacnew/.pacsave files
    local pacfiles
    pacfiles="$(find /etc -name '*.pacnew' -o -name '*.pacsave' 2>/dev/null)" || true
    if [ -n "$pacfiles" ]; then
        echo -e "\n\033[1;33m-->\033[1;34m Configuration files need attention:\033[0m"
        echo "$pacfiles" | while read -r f; do
            echo -e "  \033[2mâ€¢\033[0m $f"
        done
        echo -e "\033[2m   Review with: sudo pacdiff\033[0m"
    fi

    # Kernel update detection â€” suggest reboot
    local running_kernel installed_kernel kernel_pkg
    running_kernel="$(uname -r)"
    # Check the primary CachyOS kernel, then fall back to stock
    if pacman -Q linux-cachyos &>/dev/null; then
        kernel_pkg="linux-cachyos"
    elif pacman -Q linux &>/dev/null; then
        kernel_pkg="linux"
    else
        kernel_pkg=""
    fi

    if [ -n "$kernel_pkg" ]; then
        installed_kernel="$(pacman -Q "$kernel_pkg" | awk '{print $2}')"
        local installed_major="${installed_kernel%%-*}"
        if [[ "$running_kernel" != *"$installed_major"* ]]; then
            echo -e "\n\033[1;33m-->\033[1;32m Kernel was updated: $kernel_pkg ($running_kernel â†’ $installed_major). A reboot is recommended. ğŸ”„\033[0m"
        fi
    fi
}

# â”€â”€â”€ Arch news check (optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
check_arch_news() {
    if [[ ! -v CHECK_NEWS ]]; then
        return
    fi

    echo -e "\n\033[1;33m-->\033[1;34m Checking Arch Linux news..\033[0m"
    if command -v informant >/dev/null; then
        informant check || {
            echo -e "\033[1;33mThere are unread Arch Linux news items. Review with: sudo informant read\033[0m"
            echo -ne "\033[1;32mContinue anyway? [y/N] \033[0m"
            read -r response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                echo -e "\033[1;31mUpdate cancelled. Please review Arch news first.\033[0m"
                exit 1
            fi
        }
    elif command -v curl >/dev/null; then
        echo -e "\033[2m   Recent Arch Linux news:\033[0m"
        curl -s "https://archlinux.org/feeds/news/" 2>/dev/null \
            | grep -oP '(?<=<title>).*?(?=</title>)' \
            | head -5 \
            | while read -r title; do
                echo -e "  \033[2mâ€¢\033[0m $title"
            done
        echo -e "\033[2m   Full news: https://archlinux.org/news/\033[0m\n"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Load config
if [ -f /etc/cachy-update/config ]; then
    # shellcheck disable=SC1091
    source /etc/cachy-update/config
fi

# Parse CLI options
PARAMETERS=("$@")
PARSED_OPTIONS=$(getopt --options="anh" --longoptions="help,aur,skip-mirrorlist,no-space-check,noconfirm,news" --name "$0" -- "${PARAMETERS[@]}")
# shellcheck disable=SC2181
if [[ $? -ne 0 ]]; then
    echo -e "\033[1;31m\nFailed to parse CLI options\n\033[0m"
fi
eval set -- "$PARSED_OPTIONS"
while true; do
    case "$1" in
    -h | --help)
        source /usr/lib/cachy-update/help
        ;;
    -a | --aur)
        UPDATE_AUR=1
        shift
        ;;
    -n | --news)
        CHECK_NEWS=1
        shift
        ;;
    --skip-mirrorlist)
        SKIP_MIRRORLIST=1
        shift
        ;;
    --no-space-check)
        NO_SPACE_CHECK=1
        shift
        ;;
    --noconfirm)
        PACMAN_NOCONFIRM=1
        shift
        ;;
    --)
        shift
        if [ "$CACHY_UPDATE_SELFUPDATE" == 1 ] && [ "$#" -eq 1 ] && [ -z "$1" ]; then
            break
        fi
        PACMAN_EXTRA_OPTS+=("${@}")
        break
        ;;
    *)
        echo "Programming error"
        exit 3
        ;;
    esac
done

# â”€â”€â”€ Snapshot boot detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Refuse to update if booted into a btrfs snapshot (changes would be lost)
if grep -qE 'subvol=@/.snapshots/[0-9]+/snapshot' /proc/cmdline && [[ ! -v CACHY_SNAPSHOT_PACMAN ]]; then
    echo -e "\033[1;31mError: You are currently booted into a snapshot. Please restore the snapshot via btrfs-assistant or snapper before updating.\n\033[1;34mNote: Override with CACHY_SNAPSHOT_PACMAN=1 cachy-update\n\033[1;31mAny modifications to this snapshot will be lost on next reboot. âŒ\033[0m"
    exit 1
fi

# Start logging (we're about to modify the system)
init_logging

echo -e "\n\033[1;36mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\033[0m"
echo -e "\033[1;36mâ•‘        cachy-update v${VERSION_FLAG}              â•‘\033[0m"
echo -e "\033[1;36mâ•‘   CachyOS System Update Utility      â•‘\033[0m"
echo -e "\033[1;36mâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\033[0m\n"

# Optional: check Arch news
check_arch_news

# Refresh mirrors, then re-check self-update with new mirrors
update_mirrorlist
self_update "${PARAMETERS[@]}"

# Update keyrings before main update
update_keyrings

# Pre-update hotfixes
pre_update_routines

# Build pacman args
pacman_args=("-Su")
if [ "$DATABASE_UPDATED" != "true" ]; then
    pacman_args+=("-y")
fi

if [ -v PACMAN_EXTRA_OPTS ]; then
    pacman_args+=("${PACMAN_EXTRA_OPTS[@]}")
fi

# Run the update
do_update

# Post-update tasks
post_update_routines

# AUR update
if [[ -v UPDATE_AUR ]]; then
    if [ -x /usr/bin/paru ] && [[ -n "$SUDO_UID" ]]; then
        echo -e "\n\033[1;33m-->\033[1;34m Updating AUR packages with paru..\033[0m"
        sudo -u "#$SUDO_UID" paru -Sua || { echo -e "\033[1;31m\nParu exited with error code $?\n\033[0m"; }
    elif [ -x /usr/bin/yay ] && [[ -n "$SUDO_UID" ]]; then
        echo -e "\n\033[1;33m-->\033[1;34m Updating AUR packages with yay..\033[0m"
        sudo -u "#$SUDO_UID" yay -Sua || { echo -e "\033[1;31m\nYay exited with error code $?\n\033[0m"; }
    else
        echo -e "\n\033[1;33m--> UPDATE_AUR specified but no supported AUR helper found âŒ\033[0m"
    fi
    $INT
fi

# End routines
end_routines

echo -e "\n\033[1;32mSystem updated! ğŸ§\n\033[0m"
